;; -*- mode: emacs-lisp -*-

;; event Transfer(address indexed from, address indexed to, uint256 value);
;; event Approval(address indexed owner, address indexed spender, uint256 value);

;; Views:
;;
;; function totalSupply() external view returns (uint256);
;; function balanceOf(address account) external view returns (uint256);
;; function allowance(address owner, address spender) external view returns (uint256);
;;
;;
;;
;; Non-payable:
;;
;; function transfer(address to, uint256 value) external returns (bool);
;; function approve(address spender, uint256 value) external returns (bool);
;; function transferFrom(address from, address to, uint256 value) external returns (bool);

;; +---------+
;; | Storage |
;; +---------+

(defvar _balances    (mapping address uint256))
(defvar _allowances  (mapping address (mapping address uint256)))
(defvar _totalSupply uint256)

;; +-----------+
;; | Modifiers |
;; +-----------+

(defun notPayable ()
  (when (call-value)
    (revert "function is not payable")))

;; +---------+
;; | Helpers |
;; +---------+

(defun _assertAddress (address)
  (when (= address 0)
    (revert "zero address"))
  (defconst address-mask 0xffffffffffffffffffffffffffffffffffffffff) ; 2^160 - 1
  (let ((masked (logand address address-mask)))
    (unless (= address masked)
      (revert "invalid address"))))

(defun _update (from to value)
  (let ((fromBalance (balanceOf from))
        (toBalance   (balanceOf to  )))
    (when (< fromBalance value)
      (revert "insufficient balance"))
    (puthash _balances (- fromBalance value) from)
    (puthash _balances (+ toBalance   value) to  )
    ;; TODO: (emit Transfer)
    ))

;; +------------------+
;; | Public functions |
;; +------------------+

(defun totalSupply () _totalSupply)

(defun balanceOf (address)
  ;; TODO: Should that be non-payable?
  (_assertAddress address)
  (gethash _balances address))

(defun transfer (to value)
  (notPayable)
  (_assertAddress to)
  (notPayable))

(defun allowance (owner spender)
  (_assertAddress owner)
  (_assertAddress spender)
  (gethash _allowances owner spender))

(defun approve (spender value)
  (notPayable)
  (_assertAddress spender)
  (puthash _allowances value (caller) spender))

(defun transferFrom (from to value)
  (notPayable)
  (_assertAddress from)
  (_assertAddress to)
  
  (unless (<= value (allowance from (caller)))
    (revert "TODO: not allowed"))
  
  (unless (<= value (balanceOf from))
    (revert "TODO: not enough"))
  
  (_update from to value))

(defun name () (revert "Emacs Lisp Token"))
(defun symbol () (revert "ELT"))
(defun decimals () 18)

(defun mint ()
  (notPayable)
  (unless (< _totalSupply (ether "15803")) ; 3dbb
    (revert "maximum token limit reached"))
  (puthash _balances
           (+ (gethash _balances (caller)) (ether "1"))
           (caller))
  (setq _totalSupply (+ _totalSupply (ether "1"))))

(dispatch
 ;; IERC20
 ("totalSupply()" totalSupply)
 ("balanceOf(address)" balanceOf)
 ("transfer(address,uint256)" transfer)
 ("allowance(address,address)" allowance)
 ("approve(address,uint256)" approve)
 ("transferFrom(address,address,uint256)" transferFrom)
 ;; IERC20Metadata
 ("name()" name)
 ("symbol()" symbol)
 ("decimals()" decimals)
 ;; Other
 ("mint()" mint))
